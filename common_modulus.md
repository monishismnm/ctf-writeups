# Common Modulus RSA Challenge Write-Up
# By: Monish Polimetla
**Category:** Cryptography  
**Difficulty:** Hard  
**Challenge Type:** CTF Challenge made by Me 

## Description

Two ciphertexts are encrypted using different public exponents but the same RSA modulus. This introduces a vulnerability known as the **Common Modulus Attack**.

## Given:
n = 155371589261666216686233173264104103021615173797750183931419937487705441368200218219602709179239960784037620144166960837919055557591384299593420291902683175305284314135939589620816104181351534614269707594196429123648273000554076553557384790350333872211527021888338872082760942277622323959387427265877168575383

e1 = 65537

e2 = 17

c1 = 23470541404363149853753483522700253039614810406888421244432747026675136675890532899458820215138187644321072984728384391411291769446719124204053357936645771485601025025519395961148552765371196494600715824317272012837101419161699443308387560478054961644037832581672442514943333248277715481440928096881220277329

c2 = 2178262107624777158060385597052879061296806153689812343465475258743937844705362120650432412457464710755607739176396601116993924171708148376763540362154934984739964359569973879695223314243570363043700152290806419111683523011028631612219776620747387752498174976628343143761871355351865963911553441657362980256

---

## Goal

Recover the plaintext from the ciphertexts using RSA's vulnerability when the same modulus is used with different (coprime) exponents.

---

## Solution

This uses the **Common Modulus Attack**, which applies when the same `n` is used with two coprime exponents. Here's the solution flow:

1. Use the **Extended Euclidean Algorithm (EGCD)** to compute integers `a` and `b` such that: a * e1 + b * e2 = 1



2. Then compute: m = (c1^a * c2^b) % n


  
3. If `a` or `b` is negative, use modular inverses: m = (inverse(c1, n)^(-a) * c2^b) % n


   
---

## Analysis

```python
from Crypto.Util.number import inverse, long_to_bytes

n = 155371589261666216686233173264104103021615173797750183931419937487705441368200218219602709179239960784037620144166960837919055557591384299593420291902683175305284314135939589620816104181351534614269707594196429123648273000554076553557384790350333872211527021888338872082760942277622323959387427265877168575383
e1 = 65537
e2 = 17
c1 = 23470541404363149853753483522700253039614810406888421244432747026675136675890532899458820215138187644321072984728384391411291769446719124204053357936645771485601025025519395961148552765371196494600715824317272012837101419161699443308387560478054961644037832581672442514943333248277715481440928096881220277329
c2 = 2178262107624777158060385597052879061296806153689812343465475258743937844705362120650432412457464710755607739176396601116993924171708148376763540362154934984739964359569973879695223314243570363043700152290806419111683523011028631612219776620747387752498174976628343143761871355351865963911553441657362980256

def egcd(a, b):
    if b == 0:
        return (1, 0)
    else:
        x, y = egcd(b, a % b)
        return (y, x - (a // b) * y)

a, b = egcd(e1, e2)

if a < 0:
    c1 = inverse(pow(c1, -a, n), n)
else:
    c1 = pow(c1, a, n)

if b < 0:
    c2 = inverse(pow(c2, -b, n), n)
else:
    c2 = pow(c2, b, n)

m = (c1 * c2) % n
print(long_to_bytes(m))


##Flag
'flag{common_modulus_attack}'
