# Common Modulus RSA Challenge Write-Up  
**By:** Monish Polimetla  
**Category:** Cryptography 
**Difficulty:** Hard  
**Challenge Type:** CTF Challenge I Created  

## Description

Two ciphertexts are encrypted using different public exponents but the same RSA modulus. This introduces a vulnerability known as the **Common Modulus Attack**.

## Given:
n = 82955088765418663565673013388698412725376167701998101694288708698369130489889650795781197509660363033087269880337000714525877873842527906113207068733140314071856852021168864076615170314857314050146974195106476591593190961123406306603327554041166843799364874054736922683373665395224094006128110656305479699061

e1 = 65537

e2 = 17

c1 = 29579674390467501171314070995706278442855230000545525680665712576738302452680412311578653459356633381347926241076805460307445221256577294926704322893581200406225991495673032010266065517224483155900179989719259728742161901402516237437555731769797201185697900475168252659969182765932670327726802044580452705756

c2 = 36383438922409893874190487596115220975812810161622513683923126057120255242103634120290934051753956555303266075514382248261231588614727574706021256751163719748814506434112448056202539967185431332209442746058979531107833193163802415304005406184257725894703047057327231223181671815351802386116071412316445661570


---

## Goal

Recover the plaintext from the ciphertexts using RSA's vulnerability when the same modulus is used with different (coprime) exponents.

---

## Solution

This uses the **Common Modulus Attack**, which applies when the same `n` is used with two coprime exponents.

Steps:
1. Use the **Extended Euclidean Algorithm (EGCD)** to compute integers `a` and `b` such that:  
   `a * e1 + b * e2 = 1`

2. Compute the message:  
   `m = (c1^a * c2^b) % n`

3. If `a` or `b` is negative, use modular inverses.

---

## Analysis

```python
from Crypto.Util.number import inverse, long_to_bytes

n = 155371589261666216686233173264104103021615173797750183931419937487705441368200218219602709179239960784037620144166960837919055557591384299593420291902683175305284314135939589620816104181351534614269707594196429123648273000554076553557384790350333872211527021888338872082760942277622323959387427265877168575383
e1 = 65537
e2 = 17
c1 = 23470541404363149853753483522700253039614810406888421244432747026675136675890532899458820215138187644321072984728384391411291769446719124204053357936645771485601025025519395961148552765371196494600715824317272012837101419161699443308387560478054961644037832581672442514943333248277715481440928096881220277329
c2 = 2178262107624777158060385597052879061296806153689812343465475258743937844705362120650432412457464710755607739176396601116993924171708148376763540362154934984739964359569973879695223314243570363043700152290806419111683523011028631612219776620747387752498174976628343143761871355351865963911553441657362980256

def egcd(a, b):
    if b == 0:
        return (1, 0)
    else:
        x, y = egcd(b, a % b)
        return (y, x - (a // b) * y)

a, b = egcd(e1, e2)

if a < 0:
    c1 = inverse(pow(c1, -a, n), n)
else:
    c1 = pow(c1, a, n)

if b < 0:
    c2 = inverse(pow(c2, -b, n), n)
else:
    c2 = pow(c2, b, n)

m = (c1 * c2) % n
print(long_to_bytes(m))



##Flag
'flag{common_modulus_attack}'
